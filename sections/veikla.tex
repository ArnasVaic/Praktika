\section{Praktikos veiklos aprašymas}

\begin{activities}

    \veikla{Rašytojų poreikių analizė}
    \aprasymas{
       
        Šios veiklos tikslas buvo identifikuoti taisyklių rašytojų poreikius bei trūkumus su egzistuojančiais įrankiais. Kadangi nėra daug žmonių rašančių šias taisykles ši informacija buvo išgauta laisvos formos diskusijos metu su taisyklių rašytojais. Buvo identifikuoti šie trūkumai:

        \begin{itemize}
            \item Taisyklių rašymas viename \textit{Excel} faile nepalieka beveik jokių galimybių integruoti rašymo procesą su moderniais versijavimo įrankiais tokiais kaip \textit{Git}, todėl pokyčių ir klaidų atsekamumas yra sunkiai įgyvendinamas
            \item Taisyklių rašymas viename \textit{Excel} faile nesudaro gerų sąlygų keliems rašytojams vienu metu keisti taisykles
            \item Rašant taisykles viename \textit{Excel} faile nėra priemonių automatiškai patikrinti parašytų išraiškų sintaksinį ir semantinį korektiškumą
            \item Dabartinis interpretatorius, kuris įvykdyti aprašytas taisykles praneša tik apie pirmą pasitaikiusią klaidą, todėl klaidų taisymas užima daugiau laiko nei turėtų
            \item Dabartinis interpretatorius nepateikia pakankamai informatyvių klaidų aprašymų
        \end{itemize}

        Toliau pateikiami taisyklių rašytojų poreikiai, kurie gimė diskusijos metu arba buvo išgryninti atsižvelgiant į egzistuojančių įrankių trūkumus.

        \begin{itemize}

            \item Taisyklės turėtų būti saugomos įprasto teksto formatu (\textit{angl. plain text}), kad užtikrinti sklandžią integraciją su versijavimo įrankiu \textit{Git}

            \item Susijusių taisyklių rinkinius turėtų būti galima sugrupuoti į modulius, kurie būtų saugomi atskiruose failuose, kad įvairiems klientams galima būtų naudoti tuos pačius modulius ir taip sumažinti taisyklių kodo dubliavimą, palengvinti palaikymą bei bendradarbiavimą su kitais rašytojais
            
            \item Norint užtikrinti sklandžią taisyklių modulių sąveiką, turėtų būti įmanoma apibrėžti kontraktą, kurio privalo laikytis moduliai. Taip jie galės sąveikauti vadovaudamiesi juodosios dėžės (\textit{angl. black box}) principu. Modulio sąsaja (\textit{angl. interface}), kaip ją vadinsime, iš esmės yra analogiška sąsajoms kitose programavimo kalbose.

            \item Skirtingi klientai gali turėti specifines buhalterinių skaičiavimų taisykles todėl svarbu kiekvienam klientui turėti konfigūracinį failą, kuriame būtų nurodyti reikalingi taisyklių moduliai. Tokiu būdu būtų rašomas save dokumentuojantis kodas, kuris duotų indikaciją rašytojui, kuo specifinis klientas išsiskiria iš kitų. Šiuos konfigūraciniais failais vadinsime \textit{profiliais}
            
            \item Taisykles apdorojantis įrankius turėtų gebėti patikrinti įprastas sintaksės bei semantines taisykles, kurių principu buhalterinės taisyklės bus rašomos viename faile, todėl kartu reikėtų apibrėžti ir formalią gramatiką taisyklių moduliams bei sąsajoms

            \item Taisykles apdorojantis failas turėtų pranešti vartotojui apie visas aptiktas klaidas, kurias jis padarė, kai bandoma nauju formatu parašytas taisykles paversti į formatą, kurį supranta egzistuojantis interpretatorius
            
            \item Rašant taisykles turėtų būti galimybė naudoti sintaksės paryškinimą (\textit{angl. syntax highlighting}) norint užtikrinti lengvą kodo skaitomumą bei sumažinti kognityvinę apkrovą rašytojui

        \end{itemize}
    }
    \rezultatai{
        Identifikuoti taisyklių rašytojų poreikiai bei pagrindinės dabartinių taisyklių rašymo įrankių problemos.
    } \row

    \veikla{Technologinių sprendimų analizė}
    \aprasymas{
        Šios veiklos tikslas buvo išsiaiškinti kokie technologiniai sprendimai tenktintų taisyklių rašytojų poreikius. Buvo svarstomi du pasirinkimai, kurie galėtų patenkinti prieš tai išvardintus rašytojų poreikius bei išspręsti egzistuojančias problemas:

        \begin{itemize}
            \item Integruotos vystymo aplinkos (\textit{angl. Integrated Development Environment, IDE}) kūrimas - tai būtų kompiuterinė aplikacija, kuri apimtu visą taisyklių rašytojų darbo ciklą, nuo taisyklių rašymo, versijavimo bei paleidimo ir testavimo.
            \item Dalykinės srities kalbos kompiliatoriaus (\textit{angl. Domain Specific Language Compiler}) kūrimas - tai būtų konsolinė aplikacija, kuri gebėtų paversti paprastu tekstiniu formatu rašytoju parašytas taisykles į specifinį formatą, kurį po to galima pateikti jau egzistuojančiam taisyklių interpretatoriui. Tokiu būdu būtų pernaudojami jau egzistuojantys įrankiai.
        \end{itemize}

        Pirmasis sprendimas buvo atmestas dėl didelio kompleksiškumo, apimties bei žmogiškųjų išteklių trūkumo. Antrasis sprendimas pasirodė ypatingai patrauklus dėl to, kad būtų įmanoma naudoti tokius įrankius kaip \textit{VSCode}, kurie puikiai veikia kartu su konsolinėmis aplikacijomis. Šis įrankis pagrinde naudojamas rašyti programinį kodą, jį paleisti ir ieškoti klaidų (\textit{angl. debug}). Taip pat turi integraciją su \textit{Git} versijavimo sistema bei turi infrastruktūra pritaikytų įskiepių kūrimui, kurių pagalba būtų galima įgyvendinti sintaksės paryškinimo poreikį. Dėl šių priežasčių buvo pasirinktas antrasis sprendimas ir kiti variantai nebebuvo svarstomi.
    }
    \rezultatai{
        Pasirinktas technologinis sprendimas - dalykinės srities kalbos kompiliatorius.
    } \row

    \veikla{Įrankių projektavimas}
    \aprasymas{
        Šios veiklos tikslas buvo suprojektuoti dalykinės srities kompiliatorių ir susijusius įrankius atsižvelgiant į rašytojų išreikštus poreikius bei problemas su dabartiniais įrankiais skirtus darbui su taisyklėmis. Iš viso numatyti du įrankiai:

        \begin{itemize}
            \item Dalykinės srities kalbos kompiliatorius - konsolinė aplikacija, kuria būtų galima parsisiųsti ir įdiegti rankiniu būdu. Šis įrankis būtų rašomas su \textit{.NET} technologija pagrinde dėl to, nes ji įmonėje yra naudojama dažniausiai
 
            \item Sintaksės ryškinimo įskiepis teksto redaktoriui \textit{VSCode} - jį būtų galima atsisiųsti per \textit{VSCode} įskiepių naršyklę. Visi \textit{VSCode} įskiepiai yra įgyvendinami naudojant \textit{TypeScript} kalbą, todėl šis įskiepis irgi nėra išimtis
        \end{itemize}

        \subsubsection{Dalykinės srities kompiliatoriaus architektūra}

        Taisyklių kompiliatoriaus funkcija yra sukompiliuoti nurodytą profilį - visus modulius ir sąsajas, kurias jis aprašo. Iš poreikio sintaksės bei semantinių klaidų tikrinimui taip pat galime įvertinti, kad kompiliatoriuje turės būti lekserio bei parserio komponentai, kurie failuose parašytas taisykles galėtų suvesti į abstrakčios sintaksės medžio struktūra, kuriai būtų galima vykdyti korektiškumo tikrinimą. Šio proceso rezultatas yra vienas failas, kuriame informacija yra saugoma specifiniu formatu, kuris nėra aktualus šiai ataskaitai, tačiau ši dalis reikalaus komponento, kuris abstraktų sintaksės medį paverstų į minėta formatą. Aprašyta kompiliatoriaus darbo eiga nurodyta \ref{fig:compiler-flow}-ame pavyzdyje.

        \begin{figure}
            \centering
            \includegraphics[width=0.5\textwidth]{diagrams/compiler-flow.png}
            \caption{Dalykinės srities kompiliatoriaus kompiliavimo proceso eiga}
            \label{fig:compiler-flow}
        \end{figure}

        \paragraph{Lekserio ir parserio architektūra ir naudotos technologijos}

        Šie komponentai buvo įgyvendinti iš funkcinio programavimo paradigmos kilusiais parserių kombinatoriais (\textit{angl. parser combinators}). Šios konstrukcijos veikia pagal principą, kai mažesni, elementarūs parseriai yra sudedami į sudėtingesnes struktūras, naudojant funkcijas kaip kompozicijos priemones. Kiekvienas parseris yra funkcija, kuri gauna įvesties eilutę ir bando iš jos išgauti tam tikrą struktūrinę reikšmę, grąžindamas sėkmės arba nesėkmės rezultatą kartu su likusia analizuojama įvestimi. Kombinatoriai leidžia sujungti šiuos parserius į hierarchines sistemas, kad būtų galima apdoroti sudėtingesnes sintaksines konstrukcijas, pavyzdžiui, aritmetines išraiškas arba norimų sakinių sintaksę. 
        
        Parserių kombinatoriai yra naudojami ne tik funkciniame programavime - \textit{.NET} ekosistemoje egzistuoja keletas bibliotekų kurios įgyvendina šias konstrukcijas. Komandoje nusprendėme pasirinkti populiariausią ir plačiausiai naudojama biblioteką - \textit{Superpower}. Ši biblioteka inovatyviai panaudoja \textit{C\#} kalbos konstrukciją \textit{LINQ (angl. Language Integrated Query)} lyg tai būtų Haskell kalbos \textit{do} konstrukcija, kas leidžia elegantiškai aprašyti sudėtingus parserius. Abu komponentai -- lekseris ir parseris įgyvendinti šiuo principu, o pavizdį kaip tai atrodo, galima matyti \ref{fig:combinator-example}-ame pavyzdyje.

        \begin{figure}
            \centering
            \includegraphics[width=\textwidth]{diagrams/combinator-example.png}
            \caption{Parserio implementaciją vardo srities sakiniui parašyta naudojant \textit{C\#} kalbą}
            \label{fig:combinator-example}
        \end{figure}

        \newpage

        \paragraph{Modulių ir sąsajų apjungimo bei semantinio korektiškumo patikros komponentai}

        Pagrindinė šių komponentų funkcija yra suteikti kompiliatoriui gebėjimą patikrinti taisyklių korektiškumą, kurios referuoja į taisykles aprašytas kituose moduliuose -- tai yra esminis komponentas, kuris įgalina moduliškumą. Apjungimo komponentas suagreguoja sakinius iš skirtingų modulių į vieną didelę struktūra, kuri tada yra perduodama patikros komponentui, kur tuomet yra tikrinami tokie tarpmoduliniai ryšiai. Patikros komponentas taip pat individualiai tikrina modulių bei sąsajų vindinį semantinį korektiškumą -- kad taisyklės su tokiu pat vardu nebūtų aprašytos du kartus, kad visos sąsajoje nurodytos taisyklės būtų įgyvendintos modulyje ir \hbox{t. t.}

        Iš technologinės pusės šie moduliai nėra ypatingi, jų įgyvendinimui buvo taikomi standartinės imperatyvaus programavimo kalbų struktūros ir algoritmai.
    
        \subsubsection{Sintaksės ryškinimo įskiepis}

        \textit{VSCode} ekosistema suteikia visus reikiamus įrankius kurti pritaikytus sintaksės ryškinimo įrankius. Tai galima padaryti deklaratyviu stiliumi aprašant visų atpažįstamų žetonų formatą \textit{Regex} formatu. Visa ši konfigūracija laikoma viename \textit{JSON} formato faile kaip pavaizduota \ref{fig:vscode-theme}-ame pavyzdyje. Kaip atrodo galutinis sintaksės ryškinimo rezultatas teksto redaktoriuje \textit{VSCode} galima matyti \ref{fig:themed-logis-code}-ame pavyzdyje.

        \begin{figure}
            \centering
            \includegraphics[width=\textwidth]{diagrams/vscode-theme.png}
            \caption{Konfigūracija leidžianti atpažinti skirtingus žetonus \textit{VSCode} teksto redaktoriuje}
            \label{fig:vscode-theme}
        \end{figure}

        \begin{figure}
            \centering
            \includegraphics[width=\textwidth]{diagrams/theme-example.png}
            \caption{Dalykinės srities kalbos kodas paryškintas \textit{VSCode} teksto redaktoriuje}
            \label{fig:themed-logis-code}
        \end{figure}

    }
    \rezultatai{
        Suprojektuoti du įrankiai - dalykinės srities kalbos kompiliatorius ir sintaksės ryškinimo įskiepis \textit{VSCode} teksto redaktoriui. Aprašyta dalykinės srities kalbos kompiliatoriaus architektūra, naudojamos technologijos bei komponentai.
    } \row

    \veikla{Diegimo infrastruktūros ruošimas}
    \aprasymas{

        \subsubsection{Dalykinės srities kompiliatoriaus diegimo infrastruktūra}

        Šios veiklos tikslas buvo paruošti infrastruktūrą, kuri leistų automatizuoti įrankių diegimo procesą. Tam buvo pasitelktas \textit{GitHub Actions} funkcionalumas, kuris leidžia aprašyti automatizuotus darbo srautus (\textit{angl. workflows}). Naudojant šią technologiją, buvo sukurtas darbo srautas, kuris leidžia rankiniu būdu paleisti procesą, kuris sukompiliuoja dalykinės srities kalbos kompiliatorių ir sugeneruoja vykdomąjį failą. Šis failas yra įkeltas kaip išleidimo artefaktas (\textit{angl. release artifact}), kurį vartotojai gali atsisiųsti iš \textit{GitHub} platformos. Tokiu būdu užtikrinama, kad visada būtų prieinamas naujausias įrankio variantas, o diegimo procesas būtų paprastas ir efektyvus.

        \subsection{Sintaksės ryškinimo įskiepio diegimo infrastruktūra}

        \subsubsection{Sintaksės ryškinimo įskiepio diegimo infrastruktūra}

        Šios veiklos tikslas buvo paruošti infrastruktūrą, kuri leistų automatiškai publikuoti sintaksės ryškinimo įskiepį į \textit{VSCode} įskiepių parduotuvę (\textit{Visual Studio Code Marketplace}). Tam buvo pasitelktas \textit{GitHub Actions} funkcionalumas, kuris leidžia aprašyti automatizuotus darbo srautus (\textit{angl. workflows}). Naudojant šią technologiją, buvo sukurtas darbo srautas, kuris:

        \begin{itemize}
            \item Patikrina, ar įskiepio šaltinio kodas atitinka reikalavimus (pvz., ar nėra klaidų, ar laikomasi kodo stiliaus taisyklių).
            \item Sukompiliuoja įskiepį į reikiamą formatą (\textit{.vsix} failą).
            \item Automatiškai publikuoja įskiepį į \textit{Visual Studio Code Marketplace}, naudojant \textit{vsce} įrankį ir \textit{Personal Access Token} (PAT), kuris yra saugomas kaip \textit{GitHub Secrets}.
        \end{itemize}

        Darbo srauto konfigūracija buvo aprašyta \textit{YAML} formatu. Pavyzdys, kaip atrodo šis darbo srautas:

        \begin{minted}{yaml}
        name: Publish logis-lang
        on: workflow_dispatch

        jobs:
            publish:
                name: Publish logis-lang
                runs-on: ubuntu-latest

                steps:
                    - name: Checkout repository
                        uses: actions/checkout@v2

                    - name: Set up Node.js
                        uses: actions/setup-node@v2
                        with:
                            node-version: 22

                    - name: Install dependencies
                        run: npm install

                    - name: Install vsce
                        run: npm install -g @vscode/vsce

                    - name: Package extension
                        run: vsce package

                    - name: Publish extension
                        run: vsce publish --allow-missing-repository --skip-license -p ${{ secrets.PUBLISHER_PERSONAL_ACCESS_TOKEN }}
        \end{minted}

        Šis darbo srautas užtikrina, kad įskiepis būtų publikuojamas rankiniu būdu paleidus darbo srautą per \textit{GitHub Actions} sąsają. Tokiu būdu vartotojai visada turės prieigą prie naujausios įskiepio versijos.

    }
    \rezultatai{} \row

    % template
    % \veikla{}
    % \aprasymas{}
    % \rezultatai{} \row

\end{activities}